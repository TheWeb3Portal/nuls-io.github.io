<!DOCTYPE html>
<html lang="zh-cn">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8">
  <title>NULS共识模块解析 | NULS</title>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Canonical links -->
  <link rel="canonical" href="https://nuls-io.github.io/zh-cn/manual/consensus.html">
  <!-- Alternative links -->
  
    
      <link rel="alternative" hreflang="en" href="https://nuls-io.github.io/manual/consensus.html">
    
      <link rel="alternative" hreflang="zh-cn" href="https://nuls-io.github.io/zh-cn/manual/consensus.html">
    
  
  <!-- Icon -->
  <link rel="apple-touch-icon" sizes="57x57" href="/icon/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icon/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icon/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icon/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icon/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icon/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icon/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icon/apple-touch-icon-152x152.png">
  <link rel="icon" type="image/png" href="/icon/favicon-196x196.png" sizes="196x196">
  <link rel="icon" type="image/png" href="/icon/favicon-160x160.png" sizes="160x160">
  <link rel="icon" type="image/png" href="/icon/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/icon/favicon-16x16.png" sizes="16x16">
  <link rel="icon" type="image/png" href="/icon/favicon-32x32.png" sizes="32x32">
  <meta name="msapplication-TileColor" content="#2f83cd">
  <meta name="msapplication-TileImage" content="/icon/mstile-144x144.png">
  <meta name="generator" content="Hexo 3.8.0">
  <!-- CSS -->
  <!-- build:css build/css/nuls.css -->
  <link rel="stylesheet" href="/css/nuls.css">
  <!-- endbuild -->
  <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css">
  <!-- RSS -->
  <link rel="alternate" href="/atom.xml" title="NULS">
</head>

<body>
  <div id="container">
    <header id="header" class="wrapper">
  <div id="header-inner" class="inner">
    <h1 id="logo-wrap">
      <a href="/zh-cn/" id="logo">Hexo</a>
    </h1>
    <nav id="main-nav">
      <a href="/zh-cn/docs/" class="main-nav-link">文档</a><a href="/zh-cn/protocol/" class="main-nav-link">协议</a><a href="/zh-cn/contract/" class="main-nav-link">智能合约</a><a href="/zh-cn/chain/" class="main-nav-link">跨链</a><a href="/zh-cn/manual/" class="main-nav-link">参考手册</a><a href="/news/" class="main-nav-link">新闻</a>
    </nav>
    <div id="lang-select-wrap">
      <label id="lang-select-label"><i class="fa fa-globe"></i><span>简体中文</span></label>
      <select id="lang-select" data-canonical="manual/consensus.html">
        
          <option value="en">English</option>
        
          <option value="zh-cn" selected>简体中文</option>
        
      </select>
    </div>
    <a id="mobile-nav-toggle">
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
    </a>
  </div>
</header>

    <div id="content-wrap">
  <div id="content" class="wrapper">
    <div id="content-inner">
      <article class="article-container" itemscope="" itemtype="http://schema.org/Article">
        <div class="article-inner">
          <div class="article">
            <div class="inner">
              <header class="article-header">
                <h1 class="article-title" itemprop="name">NULS共识模块解析</h1>
                <a href="https://github.com/nuls-io/devsite/edit/master/source/zh-cn/manual/consensus.md" class="article-edit-link" title="改进本文"><i class="fa fa-pencil"></i></a>
              </header>
              <div class="article-content" itemprop="articleBody">
                <h2 id="1、模块概述" class="article-heading"><a href="#1、模块概述" class="headerlink" title="1、模块概述"></a>1、模块概述<a class="article-anchor" href="#1、模块概述" aria-hidden="true"></a></h2><p>​    众所周知，区块链的核心是共识机制。和传统互联网的cliet-server架构不同，区块链的节点是对等的，没有中心，大家权利一样；所以为了使数据达到一致性，让一个没有中心的网络维护一套大家都认同的账本，这就是共识机制的作用。<br>​<br>​<br>​    公链共识机制有多种，NULS主网采用自主原创的POC（Proof Of Credit）共识机制，一种继承了Dpos共识机制的安全性和高效率，同时在协作方面进行了非常大的改进，可以看成是一种升级版的Dpos。<br>​<br>​<br>​    NULS的共识模块，在接口层进行了高度抽象，提炼出了一些必须的功能接口，其实现为POC共识。在NULS的模块化架构基础上，可以实现其它任何可能的共识机制。期待社区、个人或者机构实现其需要的共识机制，并贡献代码到NULS的主仓库，未来可供选择的共识机制除POC外，会有POW、POS、DPOS、PBTF等多种共识算法。<br>​<br>​<br>​    本章节重点介绍NULS的共识模块接口定义，以及默认POC共识机制的实现细节。<br>​<br>​<br>​    <strong>模块信息</strong><br>​<br>​    模块名称：consensus-module<br>​<br>​    模块结构：模块顶级目录consensus-module，consesnus工程为模块接口定义，poc实现目录poc，poc实现工程consensus-poc-base，consensus-poc-protocol共识实现相关网络协议，consensus-poc-storage共识存储接口和实现工程<br>​<br>​    接口定义依赖模块：<strong>protocol-module、network-module</strong><br>​<br>​    实现额外依赖模块：<strong>core-module、ledger-module、account-module、account-ledger-module</strong></p>
<h2 id="2、模块功能" class="article-heading"><a href="#2、模块功能" class="headerlink" title="2、模块功能"></a>2、模块功能<a class="article-anchor" href="#2、模块功能" aria-hidden="true"></a></h2><p>​    本小节从两个层面来介绍NULS的共识模块功能。第一层面从对外提供的接口功能角度进行描述，外部接口是多种共识算法可能需要的共用抽象接口；第二层面从POC实现的功能需求进行概括阐述。</p>
<h3 id="2-1-外部接口" class="article-heading"><a href="#2-1-外部接口" class="headerlink" title="2.1 外部接口"></a>2.1 外部接口<a class="article-anchor" href="#2-1-外部接口" aria-hidden="true"></a></h3><ul>
<li><p>新交易：节点接收到的网络上的新交易，验证通过之后，需要放到一个统一的内存池里，以供共识模块确认这些交易（也就是打包交易到区块里）；同时接收到新的区块时，通过查找这些现场的交易，快速组装成一个完整的区块（因为新区块产生，广播给对等节点的是区块头信息和交易哈希列表）。</p>
</li>
<li><p>获取内存池交易：共识模块对外提供一个查询待确认交易列表的方法，以供其它模块有需要的时候调用。</p>
</li>
<li><p>获取单笔交易：查询一笔交易，实际上NULS系统的交易，是应该账本模块提供，但账本模块提供的交易都是已经确认的交易，未确认的交易在共识模块的内存池中，所以共识模块对外提供一个查找单笔交易的功能接口，同时包含查找未确认的交易。</p>
</li>
<li><p>新区块：</p>
<ul>
<li>下载过程中接收到下载的目标区块：一个节点刚启动，节点的本地区块数据很可能不是最新的数据，需要从其它对等节点下载增量区块，下载到的区块需要进入共识模块，通过相应的共识规则，则认为下载的区块无误，添加到主链并保存。</li>
<li>运行过程中接收到的新产生的区块：收到网络发来的一个新诞生的区块，通用协议模块会得到完整的区块信息（采取组装交易的方式，若本地找不到某些交易，则向对应的节点下载），然后把完整的区块交给共识模块进行验证–入库等操作。</li>
<li>以上两种场景，是否采用同一个业务逻辑进行处理，取决于共识机制的选择，比如POC共识，唯一不同的地方在于验证时的轮次信息不一致，前者是采用计算历史轮次来验证，后者是采用当前共识论处进行验证；如果POW共识的实现，完全可以使用同一个业务逻辑。也就是具体的实现可以自己决定是否复用代码。</li>
</ul>
</li>
<li><p>回滚区块：区块的回滚，是指当节点发现网络上有一条比本地主链更长的链可选择时，接受网络上的这条更长的链作为本地新的主链，这时需要把本地主链中，没有包含在网络上这条更长链里的区块统统删掉，相应的区块里面的交易也要进行删除（同时相应的业务逻辑也要倒退，专业术语叫做回滚）。理论上绝大部分时候，是否有分叉，是否需要分叉处理，取决于共识机制的实现方式和选择，大部分时候共识机制实现内部进行了相关的处理，共识模块提供此接口功能，以供其它模块需要时调用（比如初次启动下载，就可能需要回滚区块）。特别说明一下，不是所有的共识机制都需要回滚。</p>
</li>
</ul>
<h3 id="2-2-POC功能需求分析" class="article-heading"><a href="#2-2-POC功能需求分析" class="headerlink" title="2.2 POC功能需求分析"></a>2.2 POC功能需求分析<a class="article-anchor" href="#2-2-POC功能需求分析" aria-hidden="true"></a></h3><p>要实现POC，首先需要知道POC的设计理念和业务规则，以下内容摘自NULS白皮书POC共识介绍部分，如果熟悉可直接跳过。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">共识机制——POC</span><br><span class="line"> NULS 的模块化设计，支持共识机制在内的所有核心功能模块的替换与插拔。</span><br><span class="line">NULS 主链默认采用信用共识机制 POC(Proof-Of-Credit)。节点信用达标的情</span><br><span class="line">况下，锁定一定保证金即可加入共识，共识节点重新排序后每轮轮流出块，退出</span><br><span class="line">共识时保证金解锁。</span><br><span class="line">1、共识进入与退出机制</span><br><span class="line">任何人都可以随时加入 NULS 的共识之中，只要满足条件，遵守规则，即可</span><br><span class="line">持续获得 NULS 代币奖励。POC 的加入分为硬性指标和软性指标。硬性指标指</span><br><span class="line">的是信用分值必须达到一定标准线，排除掉一部分曾经作恶的节点。软性指标指</span><br><span class="line">的是必须冻结一定量的 NULS 代币作为保证金，为杜绝节点的泛滥，同时让整</span><br><span class="line"> 一个可定制的区块链基础设施</span><br><span class="line">9 / 15</span><br><span class="line">个系统更加公平，保证金的数量除了有一个最低值的限制外，任何人可自由选择</span><br><span class="line">保证金的数量，保证金的数量会和最终的奖励挂钩。</span><br><span class="line">1.1黄牌警告</span><br><span class="line"> 由于节点硬件配置或者网络原因，造成的共识期间掉线、死机等无法出块的，</span><br><span class="line">不属于违规情况，但对整个系统会造成一定影响，所以对这类情况，系统有一个</span><br><span class="line">轻度的警告机制：冻结保证金 72 小时，且会影响信用的评定。</span><br><span class="line">1.2红牌警告</span><br><span class="line"> 对于一些双花、尝试分叉系统、不遵守系统规则的恶意人为破坏情况，NULS</span><br><span class="line">系统坚决抵制，所有节点都可以检测到这类情况的发生；一旦有恶意节点确实试</span><br><span class="line">图挑战系统，那么对应的保证金将会被锁定 1 个月，且再次信用评级，将永远达</span><br><span class="line">不到共识门槛。</span><br><span class="line">2、信用评级</span><br><span class="line">在 NULS 系统里，信用是账户在系统中的诚信系数，所有账户的信用会在区</span><br><span class="line">间[-1,1]内，通过信用评级算法公式自动计算。</span><br><span class="line">信用评估公式：</span><br><span class="line">信用基数=能力系数+责任系数</span><br><span class="line">能力系数：根据历史出块数量计算</span><br><span class="line">责任系数：根据违规情况和出块正确性计算</span><br><span class="line">3、共识奖励</span><br><span class="line">为了整个 NULS 系统的平衡与公平，共识奖励根据所有共识节点所提交保证</span><br><span class="line">金与共识节点信用综合计算。</span><br><span class="line">共识奖励计算公式：</span><br><span class="line"> 一个可定制的区块链基础设施</span><br><span class="line">10 / 15</span><br><span class="line">fee：本块手续费</span><br><span class="line">rnc：本轮共识节点数</span><br><span class="line">bti：出块间隔时间（秒）</span><br><span class="line">spy：一年总时间（秒）</span><br><span class="line">cmc：共识抵押代币数</span><br><span class="line">cr：信用基数</span><br><span class="line">4、子链共识机制</span><br><span class="line">接入 NULS 的子链分为两种类型，第一种是通过 NULS 系统的标准接口协议</span><br><span class="line">接入，第二种是通过 NULS 的程序部署接入。</span><br><span class="line">NULS 是一套通用的区块链底层基础设施，在其主链上不运行任何应用业务，</span><br><span class="line">所有应用业务由子链运行。通过 NULS 的系统，能快速的部署基于 NULS 的子</span><br><span class="line">链，且可灵活定制子链的各种运行参数，包括是否支持基础代币、加密算法、共</span><br><span class="line">识机制、存储机制等。</span><br><span class="line">NULS 定义了标准共识模块，以提供接口兼容不同的共识机制。NULS 社区</span><br><span class="line">会陆续开发 POW、DPOS、POS、PBFT、POOL 验证池等共识机制，以供用户</span><br><span class="line">自由选择。</span><br></pre></td></tr></table></figure>
<h5 id="在POC系统中，有代理人、委托人、打包人、奖励人这四个角色。" class="article-heading"><a href="#在POC系统中，有代理人、委托人、打包人、奖励人这四个角色。" class="headerlink" title="在POC系统中，有代理人、委托人、打包人、奖励人这四个角色。"></a>在POC系统中，有代理人、委托人、打包人、奖励人这四个角色。<a class="article-anchor" href="#在POC系统中，有代理人、委托人、打包人、奖励人这四个角色。" aria-hidden="true"></a></h5><ul>
<li><p>代理人————即节点创建人，发起一笔创建共识节点的交易，记录到链中，告诉所有人我要做共识节点。节点创建的基本条件是需要锁定2万个NULS，设立这个基本条件的目的是证明你是真心实意的想维护好NULS的基础网络。</p>
</li>
<li><p>委托人————NULS持有人，可根据代理人的信用值情况，以及代理人的影响力等等因素，把自己所持有的NULS委托给该代理人进行共识，同时享受相应的共识收益，若发现代理人节点质量或者诚信有所下降，委托人可随时撤掉其委托改投他人。</p>
</li>
<li><p>打包人————代理人在创建共识节点时，可指定一个打包人，这个打包人可以是自己的其他账户，也可以是懂技术的朋友，最重要的是打包人可以不持有任何NULS，即使参与共识的服务器被黑客攻破，用户也不会有巨大损失，损失的仅仅是被攻击后的收益影响</p>
</li>
<li><p>奖励人————代理人在创建共识节点时，不仅仅可以指定一个打包人，还可以指定一个受益人，指定谁可以获得共识所产出的奖励</p>
</li>
</ul>
<h5 id="在POC系统中，有创建代理（创建共识节点）、停止代理节点（退出共识）、委托共识、取消委托四种业务逻辑。" class="article-heading"><a href="#在POC系统中，有创建代理（创建共识节点）、停止代理节点（退出共识）、委托共识、取消委托四种业务逻辑。" class="headerlink" title="在POC系统中，有创建代理（创建共识节点）、停止代理节点（退出共识）、委托共识、取消委托四种业务逻辑。"></a>在POC系统中，有创建代理（创建共识节点）、停止代理节点（退出共识）、委托共识、取消委托四种业务逻辑。<a class="article-anchor" href="#在POC系统中，有创建代理（创建共识节点）、停止代理节点（退出共识）、委托共识、取消委托四种业务逻辑。" aria-hidden="true"></a></h5><ul>
<li><p>创建代理（创建共识节点）：锁定2万个NULS，发起一笔注册代理交易，打包之后全网可见，其它人可锁定NULS委托到该代理人节点之上。</p>
</li>
<li><p>停止代理节点（退出共识）：代理人可随时停止其代理资格，发起交易删除代理节点，交易被打包确认之后，很快就会退出共识，不再参与新区块的生产。注册代理时锁定的2万个NULS会72小时之后解锁，其余委托人委托到该节点的NULS立即解锁。</p>
</li>
<li><p>委托共识：持有2000及以上NULS的用户，可以选择一个代理节点进行委托，获得相应的出块收益。在退出之前，相应委托的NULS将被锁定不可用。</p>
</li>
<li><p>取消委托：用户可对之前进行的委托进行撤销，撤销之后锁定的NULS马上解释，不再享受相应的共识收益。</p>
</li>
</ul>
<h5 id="POC系统的两种处罚机制" class="article-heading"><a href="#POC系统的两种处罚机制" class="headerlink" title="POC系统的两种处罚机制"></a>POC系统的两种处罚机制<a class="article-anchor" href="#POC系统的两种处罚机制" aria-hidden="true"></a></h5><ul>
<li><p>黄牌处罚：当出块节点因断网，卡机等各种不确定原因，导致该出块时没有出块，或者出的块没有被采用，那么将在下一轮获得黄牌处罚。黄牌处罚会影响节点的收益；当连续获得100个黄牌处罚时，会被进行红牌处罚。</p>
</li>
<li><p>红牌处罚：当出块节点作出恶意分叉、双花等严重危害网络稳定的行为时，或者连续获得100个黄牌处罚时，系统会给予红牌处罚。获得红牌处罚的节点会被强制停止共识，创建代理时的押金被冻结3个月，且永远不可再次创建节点；获得红牌处罚的节点对应的委托立即解锁。</p>
</li>
</ul>
<h5 id="POC内部系统的隐藏功能需求" class="article-heading"><a href="#POC内部系统的隐藏功能需求" class="headerlink" title="POC内部系统的隐藏功能需求"></a>POC内部系统的隐藏功能需求<a class="article-anchor" href="#POC内部系统的隐藏功能需求" aria-hidden="true"></a></h5><ul>
<li><p>维护一张代理人信息表，并根据实时接收到的以上四种交易进行更新。</p>
</li>
<li><p>维护一个轮次信息表，让每个轮次符合出块条件的代理人随机排队出块。</p>
</li>
<li><p>符合出块条件的代理节点，对内存池的交易进行验证打包，组装成新区块并广播到全网。</p>
</li>
<li><p>分叉处理。</p>
</li>
</ul>
<p>以上是对共识模块POC共识机制实现的功能分析，在[<strong>核心流程</strong>] (#core-processer)小节中会介绍每个功能实现的细节。</p>
<h2 id="3、模块接口" class="article-heading"><a href="#3、模块接口" class="headerlink" title="3、模块接口"></a>3、模块接口<a class="article-anchor" href="#3、模块接口" aria-hidden="true"></a></h2><p>共识模块的外部接口定义类为io.nuls.consensus.service.ConsensusService<br>，处于consensus工程下面。</p>
<ul>
<li><p><strong>新交易</strong></p>
<ul>
<li>方法名称: newTx</li>
<li><p>方法说明:</p>
<ul>
<li>节点接收到的网络上或本地产生的新交易，经过初步验证，通过之后放入交易内存池，等待确认。</li>
</ul>
</li>
<li><p>参数说明:</p>
<ul>
<li>tx : 交易（Transaction)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>返回值说明:</p>
<ul>
<li>类型：Result</li>
<li>字段：<pre><code>* success : 返回是否处理成功
</code></pre></li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * receive a new transaction, add in memory pool after verify success</span><br><span class="line">  * @param tx</span><br><span class="line">  * @return Result</span><br><span class="line">  */</span><br><span class="line"> Result newTx(Transaction&lt;? extends BaseNulsData&gt; tx);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>新区块诞生</strong></p>
<ul>
<li>方法名称: newBlock</li>
<li><p>方法说明:</p>
<ul>
<li><p>收到网络发来的一个新诞生的区块，通用协议模块会得到完整的区块信息（采取组装交易的方式，若本地找不到某些交易，则向对应的节点下载），然后把完整的区块交给共识模块进行验证–入库等操作。</p>
<pre><code>在接口类里有两个重载方法，是否明确知道是从哪个对等节点接收到的新区块。
</code></pre></li>
</ul>
</li>
<li><p>参数说明:</p>
<ul>
<li>block : 完整的区块信息（Block)</li>
<li>node :  接收到的对等节点信息（Node)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>返回值说明:</p>
<ul>
<li>类型：Result</li>
<li>字段：<pre><code>* success : 返回是否处理成功
</code></pre></li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * receive block from other peers</span><br><span class="line">   * @param block</span><br><span class="line">   * @return Result</span><br><span class="line">   */</span><br><span class="line">  Result newBlock(Block block);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * receive block from other peers</span><br><span class="line">   * @param block</span><br><span class="line">   * @param node</span><br><span class="line">   * @return Result</span><br><span class="line">   */</span><br><span class="line">  Result newBlock(Block block, Node node);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>添加一个区块到主链之上</strong></p>
<ul>
<li>方法名称: addBlock</li>
<li><p>方法说明:</p>
<ul>
<li>当本地区块低于网络最新高度时，需要从网络下载最新的增量区块，下载到区块之后调用该方法进行添加，把区块连接到本地主链之上。</li>
</ul>
</li>
<li><p>参数说明:</p>
<ul>
<li>block : 完整的区块信息（Block)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>返回值说明:</p>
<ul>
<li>类型：Result</li>
<li>字段：<pre><code>* success : 返回是否处理成功
</code></pre></li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * synchronous block from other peers</span><br><span class="line">  * @param block</span><br><span class="line">  * @return Result</span><br><span class="line">  */</span><br><span class="line"> Result addBlock(Block block);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>回滚区块</strong></p>
<ul>
<li>方法名称: rollbackBlock</li>
<li><p>方法说明:</p>
<ul>
<li>撤销本地主链中的最新一个区块，当传入的区块不是本地主链最新区块时，会返回失败；在POC的实现中，会优先回滚内存中主链的最优区块，成功之后再进行数据库的相应地回滚。</li>
</ul>
</li>
<li><p>参数说明:</p>
<ul>
<li>block : 完整的区块信息（Block)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>返回值说明:</p>
<ul>
<li>类型：Result</li>
<li>字段：<pre><code>* success : 返回是否处理成功
</code></pre></li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Roll back the latest block and roll back the status of the chain in the consensus service memory</span><br><span class="line">  *</span><br><span class="line">  * 回滚最新区块，同时回滚共识服务内存中链的状态</span><br><span class="line">  * @return Result</span><br><span class="line">  */</span><br><span class="line"> Result rollbackBlock(Block block) throws NulsException;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>获取内存池的交易列表</strong></p>
<ul>
<li>方法名称: getMemoryTxs</li>
<li><p>方法说明:</p>
<ul>
<li>获取内存池中的所有交易</li>
</ul>
</li>
<li><p>参数说明:</p>
<ul>
<li>没有参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>返回值:</p>
<ul>
<li>类型：List\<transaction></transaction></li>
<li>说明：交易集合</li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Get all the transactions in the memory pool</span><br><span class="line">  *</span><br><span class="line">  * 获取内存池里面的所有交易</span><br><span class="line">  * @return List&lt;Transaction&gt;</span><br><span class="line">  */</span><br><span class="line"> List&lt;Transaction&gt; getMemoryTxs();</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>获取单笔交易</strong></p>
<ul>
<li>方法名称: getTx</li>
<li><p>方法说明:</p>
<ul>
<li>查询一笔交易，实际上NULS系统的交易，是应该账本模块提供，但账本模块提供的交易都是已经确认的交易，未确认的交易在共识模块的内存池中，所以共识模块对外提供一个查找单笔交易的功能接口，同时包含查找未确认的交易。</li>
</ul>
</li>
<li><p>参数说明:</p>
<ul>
<li>hash : 交易hash（NulsDigestData)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>返回值:</p>
<ul>
<li>类型：Transaction</li>
<li>说明：交易对象，如果没有则为null</li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transaction getTx(NulsDigestData hash);</span><br></pre></td></tr></table></figure>
<h2 id="4、模块架构" class="article-heading"><a href="#4、模块架构" class="headerlink" title="4、模块架构"></a>4、模块架构<a class="article-anchor" href="#4、模块架构" aria-hidden="true"></a></h2><p><img src="consensus/1.png" alt="tips"></p>
<h2 id="5、模块协议" class="article-heading"><a href="#5、模块协议" class="headerlink" title="5、模块协议"></a>5、模块协议<a class="article-anchor" href="#5、模块协议" aria-hidden="true"></a></h2><h3 id="TX-TYPE-REGISTER-AGENT" class="article-heading"><a href="#TX-TYPE-REGISTER-AGENT" class="headerlink" title="TX_TYPE_REGISTER_AGENT"></a>TX_TYPE_REGISTER_AGENT<a class="article-anchor" href="#TX-TYPE-REGISTER-AGENT" aria-hidden="true"></a></h3><table>
<thead>
<tr>
<th>尺寸</th>
<th>字段</th>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>type</td>
<td>uint16</td>
<td>4</td>
</tr>
<tr>
<td>6</td>
<td>time</td>
<td>uint48</td>
<td>时间戳</td>
</tr>
<tr>
<td>??</td>
<td>remark</td>
<td>VarByte</td>
<td>备注数据</td>
</tr>
<tr>
<td>8</td>
<td>deposit</td>
<td>uint64</td>
<td>抵押金额</td>
</tr>
<tr>
<td>23</td>
<td>agentAddress</td>
<td>Address</td>
<td>节点地址</td>
</tr>
<tr>
<td>23</td>
<td>packingAddress</td>
<td>Address</td>
<td>打包地址</td>
</tr>
<tr>
<td>23</td>
<td>rewardAddress</td>
<td>Address</td>
<td>奖励地址</td>
</tr>
<tr>
<td>8</td>
<td>commissionRate</td>
<td>Double</td>
<td>昵称</td>
</tr>
<tr>
<td>??</td>
<td>coinData</td>
<td>CoinData</td>
<td>交易 UTXO</td>
</tr>
<tr>
<td>??</td>
<td>scriptSign</td>
<td>VarByte</td>
<td>P2PKHScriptSig</td>
</tr>
</tbody>
</table>
<h3 id="TX-TYPE-JOIN-CONSENSUS" class="article-heading"><a href="#TX-TYPE-JOIN-CONSENSUS" class="headerlink" title="TX_TYPE_JOIN_CONSENSUS"></a>TX_TYPE_JOIN_CONSENSUS<a class="article-anchor" href="#TX-TYPE-JOIN-CONSENSUS" aria-hidden="true"></a></h3><table>
<thead>
<tr>
<th>尺寸</th>
<th>字段</th>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>type</td>
<td>uint16</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>time</td>
<td>uint48</td>
<td>时间戳</td>
</tr>
<tr>
<td>??</td>
<td>remark</td>
<td>VarByte</td>
<td>备注数据</td>
</tr>
<tr>
<td>8</td>
<td>deposit</td>
<td>byte[]</td>
<td>委托金额</td>
</tr>
<tr>
<td>23</td>
<td>address</td>
<td>byte[23]</td>
<td>地址</td>
</tr>
<tr>
<td>8</td>
<td>agentHash</td>
<td>NulsDigestData</td>
<td>委托节点地址</td>
</tr>
<tr>
<td>??</td>
<td>coinData</td>
<td>CoinData</td>
<td>交易 UTXO</td>
</tr>
<tr>
<td>??</td>
<td>scriptSign</td>
<td>VarByte</td>
<td>P2PKHScriptSig</td>
</tr>
</tbody>
</table>
<h3 id="TX-TYPE-CANCEL-DEPOSIT" class="article-heading"><a href="#TX-TYPE-CANCEL-DEPOSIT" class="headerlink" title="TX_TYPE_CANCEL_DEPOSIT"></a>TX_TYPE_CANCEL_DEPOSIT<a class="article-anchor" href="#TX-TYPE-CANCEL-DEPOSIT" aria-hidden="true"></a></h3><table>
<thead>
<tr>
<th>尺寸</th>
<th>字段</th>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>type</td>
<td>uint16</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>time</td>
<td>uint48</td>
<td>时间戳</td>
</tr>
<tr>
<td>??</td>
<td>remark</td>
<td>VarByte</td>
<td>备注数据</td>
</tr>
<tr>
<td>??</td>
<td>agentHash</td>
<td>NulsDigestData</td>
<td>委托节点地址</td>
</tr>
<tr>
<td>??</td>
<td>coinData</td>
<td>CoinData</td>
<td>交易 UTXO</td>
</tr>
<tr>
<td>??</td>
<td>scriptSign</td>
<td>VarByte</td>
<td>P2PKHScriptSig</td>
</tr>
</tbody>
</table>
<h3 id="TX-TYPE-STOP-AGENT" class="article-heading"><a href="#TX-TYPE-STOP-AGENT" class="headerlink" title="TX_TYPE_STOP_AGENT"></a>TX_TYPE_STOP_AGENT<a class="article-anchor" href="#TX-TYPE-STOP-AGENT" aria-hidden="true"></a></h3><table>
<thead>
<tr>
<th>尺寸</th>
<th>字段</th>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>type</td>
<td>uint16</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>time</td>
<td>uint48</td>
<td>时间戳</td>
</tr>
<tr>
<td>??</td>
<td>remark</td>
<td>VarByte</td>
<td>备注数据</td>
</tr>
<tr>
<td>??</td>
<td>agentHash</td>
<td>NulsDigestData</td>
<td>停止节点地址</td>
</tr>
<tr>
<td>??</td>
<td>coinData</td>
<td>CoinData</td>
<td>交易 UTXO</td>
</tr>
<tr>
<td>??</td>
<td>scriptSign</td>
<td>VarByte</td>
<td>P2PKHScriptSig</td>
</tr>
</tbody>
</table>
<h3 id="TX-TYPE-YELLOW-PUNISH" class="article-heading"><a href="#TX-TYPE-YELLOW-PUNISH" class="headerlink" title="TX_TYPE_YELLOW_PUNISH"></a>TX_TYPE_YELLOW_PUNISH<a class="article-anchor" href="#TX-TYPE-YELLOW-PUNISH" aria-hidden="true"></a></h3><table>
<thead>
<tr>
<th>尺寸</th>
<th>字段</th>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>type</td>
<td>uint16</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>time</td>
<td>uint48</td>
<td>时间戳</td>
</tr>
<tr>
<td>??</td>
<td>remark</td>
<td>VarByte</td>
<td>备注数据</td>
</tr>
<tr>
<td>??</td>
<td>count</td>
<td>VarInt</td>
<td>惩罚数量</td>
</tr>
<tr>
<td>??</td>
<td>addres</td>
<td>Address[]</td>
<td>被黄牌警告的节点地址</td>
</tr>
<tr>
<td>??</td>
<td>coinData</td>
<td>CoinData</td>
<td>交易 UTXO</td>
</tr>
<tr>
<td>??</td>
<td>scriptSign</td>
<td>VarByte</td>
<td>P2PKHScriptSig</td>
</tr>
</tbody>
</table>
<h3 id="TX-TYPE-RED-PUNISH" class="article-heading"><a href="#TX-TYPE-RED-PUNISH" class="headerlink" title="TX_TYPE_RED_PUNISH"></a>TX_TYPE_RED_PUNISH<a class="article-anchor" href="#TX-TYPE-RED-PUNISH" aria-hidden="true"></a></h3><table>
<thead>
<tr>
<th>尺寸</th>
<th>字段</th>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>type</td>
<td>uint16</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>time</td>
<td>uint48</td>
<td>时间戳</td>
</tr>
<tr>
<td>??</td>
<td>remark</td>
<td>VarByte</td>
<td>备注数据</td>
</tr>
<tr>
<td>23</td>
<td>address</td>
<td>byte[23]</td>
<td>惩罚数量</td>
</tr>
<tr>
<td>1</td>
<td>reasonCode</td>
<td>byte</td>
<td>处罚代码</td>
</tr>
<tr>
<td>??</td>
<td>evidence</td>
<td>VarByte</td>
<td>证据</td>
</tr>
<tr>
<td>??</td>
<td>coinData</td>
<td>CoinData</td>
<td>交易 UTXO</td>
</tr>
<tr>
<td>??</td>
<td>scriptSign</td>
<td>VarByte</td>
<td>P2PKHScriptSig</td>
</tr>
</tbody>
</table>
<h2 id="6、核心流程" class="article-heading"><a href="#6、核心流程" class="headerlink" title=" 6、核心流程"></a><a name="core-processer"></a> 6、核心流程<a class="article-anchor" href="#6、核心流程" aria-hidden="true"></a></h2><h4 id="创建代理" class="article-heading"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理<a class="article-anchor" href="#创建代理" aria-hidden="true"></a></h4><ul>
<li><p>简述</p>
<ul>
<li>任何持有2万及以上NULS的用户，都可以通过钱包共识界面的创建委托（Linux通过命令行命令，或者可以通过rpc命令）功能进行创建代理。创建之后验证交易并广播到全网等待确认。</li>
<li>该笔创建代理交易被确认之后，打包地址所在的节点，会在2轮之后开始共识。</li>
</ul>
</li>
<li><p>流程图<br><img src="consensus/2.png" alt="tips"></p>
</li>
<li><p>代码解释</p>
<ul>
<li><p>入口为consensus-poc-rpc工程下的io.nuls.consensus.poc.rpc.resource.PocConsensusResource类，对应的createAgent方法。</p>
</li>
<li><p>PocConsensusResource里的createAgent方法，先验证参数的合法性（包括地址不能重复，不能为空，创建账户要在本地账户中能找到，账户密码的正确性等），再组装交易然后调用txProcessing方法进行签名验证并广播。</p>
</li>
<li><p>对应的网络协议定义在consensus-poc-protocol工程下的io.nuls.consensus.poc.protocol.tx.CreateAgentTransaction；</p>
</li>
<li><p>与协议绑定的处理器在consensus-poc-base工程下的io.nuls.consensus.poc.tx.processor.CreateAgentTxProcessor；</p>
</li>
<li><p>验证器有3个，分别是consensus-poc-base工程下的io.nuls.consensus.poc.tx.validator.AgentAddressesValidator、io.nuls.consensus.poc.tx.validator.AgentCountValidator、io.nuls.consensus.poc.tx.validator.CreateAgentTxValidator</p>
</li>
<li><p>CreateAgentTransaction在打包时会调用verify方法进行验证，也就是分别调用3个绑定的验证，都返回true代表验证成功；打包成功之后会调用CreateAgentTxProcessor保存到数据库。</p>
</li>
<li><p>该笔交易被打包进区块之后，会通过io.nuls.consensus.poc.process.BlockProcess里的addBlock方法进行保存区块，保存区块时，首先会做一些基本的验证，验证区块头是否合法，该区块是否包含双花的交易等，接着会验证打包人是否合法，代码为</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean verifyAndAddBlockResult = chainManager.getMasterChain().verifyAndAddBlock(block, isDownload);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>运行到这里之后，一旦成功，该笔创建委托的交易就放在了主链ChainContainer对应Chain的agentList里，下次计算轮次的时候，就会包含这条数据。

**同理下面的委托共识、停止代理、取消共识交易在打包进区块之后，也是一样的处理流程**
</code></pre><h4 id="委托共识" class="article-heading"><a href="#委托共识" class="headerlink" title="委托共识"></a>委托共识<a class="article-anchor" href="#委托共识" aria-hidden="true"></a></h4><ul>
<li><p>简述</p>
<ul>
<li>持有2000NULS以上的用户，可以选择委托支持代理节点进行共识，获取相应的收益。</li>
</ul>
</li>
<li><p>流程图</p>
</li>
</ul>
<p><img src="consensus/3.png" alt="tips"></p>
<ul>
<li><p>代码解释</p>
<ul>
<li><p>入口为consensus-poc-rpc工程下的io.nuls.consensus.poc.rpc.resource.PocConsensusResource类，对应的depositToAgent方法。</p>
</li>
<li><p>PocConsensusResource里的depositToAgent方法，先验证参数的合法性（包括代理hash不能为空并且存在，委托账户不能为空且要在本地账户中能找到，账户密码的正确性等），再组装DepositTransaction交易然后调用txProcessing方法进行签名验证并广播。</p>
</li>
<li><p>对应的网络协议定义在consensus-poc-protocol工程下的io.nuls.consensus.poc.protocol.tx.DepositTransaction；</p>
</li>
<li><p>与协议绑定的处理器在consensus-poc-base工程下的io.nuls.consensus.poc.tx.processor.DepositTxProcessor；</p>
</li>
<li><p>验证器是consensus-poc-base工程下的io.nuls.consensus.poc.tx.validator.DepositTxValidator</p>
</li>
<li><p>DepositTransaction在打包时会调用verify方法进调用绑定的验证器行验证，返回true代表验证成功；打包成功之后会调用DepositTxProcessor保存到数据库。</p>
</li>
</ul>
</li>
</ul>
<h4 id="停止代理" class="article-heading"><a href="#停止代理" class="headerlink" title="停止代理"></a>停止代理<a class="article-anchor" href="#停止代理" aria-hidden="true"></a></h4><ul>
<li><p>简述</p>
<ul>
<li>成功注册代理的节点，可随时选择停止代理，但保证金会被锁定72小时，委托到该代理节点的立即解锁。</li>
</ul>
</li>
<li><p>流程图<br><img src="consensus/4.png" alt="tips"></p>
</li>
<li><p>代码解释</p>
<ul>
<li><p>入口为consensus-poc-rpc工程下的io.nuls.consensus.poc.rpc.resource.PocConsensusResource类，对应的stopAgent方法。</p>
</li>
<li><p>PocConsensusResource里的stopAgent方法，先验证参数的合法性（包括代理hash不能为空并且存在，并且是自己创建的代理，账户不能为空且要在本地账户中能找到，账户密码的正确性等），再组装StopAgentTransaction交易然后调用txProcessing方法进行签名验证并广播。</p>
</li>
<li><p>在组装StopAgentTransaction时，会把之前创建代理时锁定的保证金当作本次输入，输出一个对应锁定时间的output，相当于把之前的保证金花费掉，重新锁定一定的时间。</p>
</li>
</ul>
</li>
</ul>
<pre><code>* 对应的网络协议定义在consensus-poc-protocol工程下的io.nuls.consensus.poc.protocol.tx.StopAgentTransaction；

* 与协议绑定的处理器在consensus-poc-base工程下的io.nuls.consensus.poc.tx.processor.StopAgentTxProcessor；

* 验证器是consensus-poc-base工程下的io.nuls.consensus.poc.tx.validator.StopAgentTxValidator

* StopAgentTransaction在打包时会调用verify方法调用绑定的验证器进行验证，返回true代表验证成功；打包成功之后会调用StopAgentTxProcessor保存到数据库；在StopAgentTxProcessor执行的时候，会把该代理节点对应的所有委托，都取消并解锁。
</code></pre><h4 id="取消委托" class="article-heading"><a href="#取消委托" class="headerlink" title="取消委托"></a>取消委托<a class="article-anchor" href="#取消委托" aria-hidden="true"></a></h4><ul>
<li><p>简述</p>
<ul>
<li>委托人随时可对代理节点的委托进行撤销，锁定的保证金立即解锁。</li>
</ul>
</li>
<li><p>流程图</p>
</li>
</ul>
<p><img src="consensus/5.png" alt="tips"></p>
<ul>
<li><p>代码解释</p>
<ul>
<li><p>入口为consensus-poc-rpc工程下的io.nuls.consensus.poc.rpc.resource.PocConsensusResource类，对应的withdraw方法。</p>
</li>
<li><p>PocConsensusResource里的withdraw方法，先验证参数的合法性（包括代理hash不能为空并且存在，并且是自己创建的代理，账户不能为空且要在本地账户中能找到，账户密码的正确性等），再组装CancelDepositTransaction交易然后调用txProcessing方法进行签名验证并广播。</p>
</li>
<li><p>在组装CancelDepositTransaction时，会把之前委托时锁定的保证金当作本次输入，输出一个马上可用的output，相当于把之前的保证金花费掉，付给自己。</p>
</li>
<li><p>对应的网络协议定义在consensus-poc-protocol工程下的io.nuls.consensus.poc.protocol.tx. CancelDepositTransaction；</p>
</li>
<li><p>与协议绑定的处理器在consensus-poc-base工程下的io.nuls.consensus.poc.tx.processor.CancelDepositTxProcessor；</p>
</li>
<li><p>验证器是consensus-poc-base工程下的io.nuls.consensus.poc.tx.validator.CancelDepositTxValidator</p>
</li>
<li><p>CancelDepositTransaction在打包时会调用verify方法调用绑定的验证器进行验证，返回true代表验证成功；打包成功之后会调用CancelDepositTxProcessor保存到数据库。</p>
</li>
</ul>
</li>
</ul>
<h4 id="共识轮次" class="article-heading"><a href="#共识轮次" class="headerlink" title="共识轮次"></a>共识轮次<a class="article-anchor" href="#共识轮次" aria-hidden="true"></a></h4><ul>
<li><p>简述</p>
<ul>
<li>NULS系统初始，会内置5个种子共识节点，网络的最初期由这5个种子共识节点负责维护初期网络数据；这5个种子节点没有锁定的保证金，故这5个种子节点不参与共识奖励（手续费除外）。</li>
<li>一旦NULS系统开始运行，则后续注册的共识节点，会陆续加入到NULS的网络维护中，代理节点注册成功之后，只需满足20万NULS委托额，即可参与共识。</li>
<li>所有满足共识条件的代理节点（包括5个种子节点），维护网络的权重相当（也就是代理节点之间的权限一样，不存在委托额大的权限大），具有相同的出块机会，大家通过共识算法轮流随机进行出块。</li>
<li>所有满足共识条件的代理人，每人出一个块的这个周期，就叫做共识轮次；一个轮次里，每人拥有一次出块机会，且不同的轮次出块的顺序是随机的。</li>
</ul>
</li>
<li><p>流程图<br><img src="consensus/6.png" alt="tips"></p>
</li>
<li><p>代码解释</p>
<ul>
<li><p>流程入口为consensus-poc-base工程下的io.nuls.consensus.poc.scheduler.ConsensusScheduler类，里面的initDatas方法会io.nuls.consensus.poc.manager.CacheManager的load方法进行数据的初始化。</p>
</li>
<li><p>CacheManager的load方法会先从数据库加载系统所需要的数据（包括最近100轮的区块头、最近10个完整的区块、所有的代理、委托、停止代理和取消委托记录、红黄牌记录），接着组装一个io.nuls.consensus.poc.container.ChainContainer为主链，设置到chainManager之中。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  接着会调用io.nuls.consensus.poc.manager.RoundManager的initRound方法初始化最近的轮次信息。初始化成功之后会放到RoundManager的roundList里。</span><br><span class="line"></span><br><span class="line">* 轮次的使用：</span><br><span class="line">	</span><br><span class="line">  io.nuls.consensus.poc.container.ChainContainer的verifyBlock方法。首先会通过roundManager.getCurrentRound()获取当前的轮次信息，和区块头里面的轮次信息对比，如果不是想要的轮次，那么再次调用roundManager.getRoundByIndex方法获取想要的轮次；或者调用roundManager.getNextRound获取当前轮次的下一个轮次（在RoundManager里面没有最新轮次的情况下）。</span><br><span class="line"></span><br><span class="line">* 轮次的变换：</span><br><span class="line"></span><br><span class="line">  轮次的变换有两个途径，第一种就是上面结束的roundManager.getNextRound。第二种在io.nuls.consensus.poc.process.ConsensusProcess的doWork里，代码为</span><br><span class="line">  </span><br><span class="line">  ``` MeetingRound round = chainManager.getMasterChain().getOrResetCurrentRound();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>系统每1000毫秒会执行一次doWork方法，最终会调用RoundManager的resetRound(true)方法获取轮次，如果当前轮次已经结束，那么会返回新一轮的轮次信息。
</code></pre><h4 id="打包区块" class="article-heading"><a href="#打包区块" class="headerlink" title="打包区块"></a>打包区块<a class="article-anchor" href="#打包区块" aria-hidden="true"></a></h4><ul>
<li>简述<ul>
<li>满足共识条件的代理人，对应设置的出块地址所在节点，每一轮都拥有一次出块机会。</li>
<li>在节点启动之后，共识模块的任务调度器会启动一个打包区块的任务器，这个任务器会实时监控当前节点所有未加密账户是否成为打包节点。</li>
<li>如果节点有未加密账户成为了代理节点的出块节点，那么打包区块的任务器会监控代理节点是否满足共识出块条件，一旦满足，则在下一轮启动共识，按共识规则进行打包出块。</li>
</ul>
</li>
</ul>
<ul>
<li>流程图</li>
</ul>
<p><img src="consensus/7.png" alt="tips"></p>
<ul>
<li><p>代码解释</p>
<ul>
<li><p>共识打包器的启动，在io.nuls.consensus.poc.scheduler.ConsensusScheduler的start方法里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConsensusProcess consensusProcess = <span class="keyword">new</span> ConsensusProcess(chainManager);</span><br><span class="line">   threadPool.scheduleAtFixedRate(<span class="keyword">new</span> ConsensusProcessTask(consensusProcess), <span class="number">1000L</span>, <span class="number">1000L</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>* io.nuls.consensus.poc.task.ConsensusProcessTask每一秒钟会调用一次ConsensusProcess的process方法。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consensusProcess.process();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


* io.nuls.consensus.poc.process.ConsensusProcess会先根据共识模块的状态、配置是否打包、网络情况等，判断是否继续处理打包。

* 进入doWork方法之后，先获取轮次信息，再通过获取到的轮次信息判断是否有需要出块的账户所对应的出块信息（包括出块时间，顺序索引，奖励地址、委托列表、信用值等），如果没有，则代表该节点不需要出块，那么调用clearTxMemoryPool方法定期清除内存池里面的交易。

* 如果需要打包，则判断当前时间是否达到了应该出块的时间，如果达到了，就调用packing方法进行打包。

* packing会先调用waitReceiveNewestBlock进行等待上一个块的接收，若上一个节点正常出块并正常及时接收到，那么就开始打包，若上一个节点没能及时打包或者网络传输太差的情况，那么最多等待出块时间间隔的1/2也就是5秒，超时之后就算没有接收到上一个块，也需要进行打包。

* 调用doPacking进行打包区块的操作；流程依次是组装区块轮次信息 -&gt; 验证内存池里面的交易 -&gt; 时间结束或者区块大小达到上限 -&gt; 验证区块里的交易（包括业务冲突检测）-&gt; 调用addConsensusTx方法组装coinbase交易（奖励）和红黄牌处罚交易组装 -&gt; 调用ConsensusTool.createBlock组装完整的区块。

* 如果上一个块在打包之前没有受到，那么再次检测上一个区块是否收到，如果收到了，那么就再次重新打包，因为交易有可能重复了。

* 最后就是保存区块（saveBlock方法），广播区块（broadcastSmallBlock方法）。
</code></pre><h4 id="区块验证" class="article-heading"><a href="#区块验证" class="headerlink" title="区块验证"></a>区块验证<a class="article-anchor" href="#区块验证" aria-hidden="true"></a></h4><ul>
<li><p>简述</p>
<ul>
<li>任何NULS节点，收到来自网络上其它对等节点发来的新区块时，都会对区块进行校验，只有合法的区块才能被正确的添加到主链之中，不合法的区块则沦为孤块。</li>
<li>验证区块除了验证区块的基本信息之外（比如区块上限，签名，上一区块hash引用等），最重要的是验证区块的签名者是否合法。</li>
<li>要验证区块的签名者是否合法，需要验证区块签名者是否有对应的代理节点，对应的代理节点是否满足共识出块条件，该区块的时间段是否应该对应的代理节点出块。</li>
</ul>
</li>
<li><p>流程图<br><img src="consensus/8.png" alt="tips"></p>
</li>
<li><p>代码解释</p>
<ul>
<li><p>io.nuls.consensus.poc.service.impl.ConsensusPocServiceImpl为共识模块对外接口io.nuls.consensus.service.ConsensusService的实现。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Result <span class="title">newBlock</span><span class="params">(Block block)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> newBlock(block, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">		</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Result <span class="title">newBlock</span><span class="params">(Block block, Node node)</span> </span>&#123;</span><br><span class="line">       BlockContainer blockContainer = <span class="keyword">new</span> BlockContainer(block, node, BlockContainerStatus.RECEIVED);</span><br><span class="line">       <span class="keyword">boolean</span> success = blockQueueProvider.put(blockContainer);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Result(success, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">		</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Result <span class="title">addBlock</span><span class="params">(Block block)</span> </span>&#123;</span><br><span class="line">       BlockContainer blockContainer = <span class="keyword">new</span> BlockContainer(block, BlockContainerStatus.DOWNLOADING);</span><br><span class="line">       <span class="keyword">boolean</span> success = blockQueueProvider.put(blockContainer);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Result(success, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>* 当共识模块接收到一个新区块的请求时，会把这个块存放到一个区块队列提供器里，也就是blockQueueProvider进行异步处理。

* io.nuls.consensus.poc.task.BlockProcessTask为ConsensusScheduler启动的一个区块处理任务，这个任务每300ms执行一次；当区块队列里面有新的区块时，BlockProcessTask会把新的区块交给io.nuls.consensus.poc.process.BlockProcess的addBlock方法进行处理。

* BlockProcess的addBlock方法会首先验证区块的时，如果比当前的时间大，那么直接丢弃，接着验证区块的基本信息（区块是否合法），对应的区块验证器在protocol工程里，分别是：

        io.nuls.protocol.model.validator.BlockFieldValidator

        io.nuls.protocol.model.validator.BlockHeaderValidator

        io.nuls.protocol.model.validator.BlockMaxSizeValidator

        io.nuls.protocol.model.validator.BlockMerkleValidator

        io.nuls.protocol.model.validator.HeaderFieldValidator

        io.nuls.protocol.model.validator.HeaderSignValidator

* 接着bifurcationUtil.validate(block.getHeader())验证区块对应打包人是否存在恶意分叉情况（在同一轮里打出了多个块），如果存在恶意情况则给出红牌处罚。

* ledgerService.verifyDoubleSpend(block)验证本区块是否存在双花交易，如果存在给出红牌处罚。

* **chainManager.getMasterChain().verifyAndAddBlock(block, isDownload)** 验证区块的打包人是否合法，同时验证区块的coinbase交易和处罚交易（如果存在的话），都验证通过那么就把本区块加入到内存中的主链之上（同时处理该区块包含的创建代理、委托、停止代理、取消委托、红黄牌处罚交易）。

* 上述成功的情况下，继续验证本区块的交易，先验证交易签名（为提供效率，多线程异步验证），再验证交易的utxo是否合法 **ledgerService.verifyCoinData(tx, toMaps, fromSet)**，最后验证交易的业务逻辑冲突 **tansactionService.conflictDetect(block.getTxs())**。

* 交易验证通过之后，保存区块 **blockService.saveBlock(block)**。

* 最后设置系统最新区块，并转发给其它对等节点。

* 如果上述步骤失败的区块下，会回滚内存主链的数据 **chainManager.getMasterChain().rollback(block)**。
</code></pre><h4 id="分叉处理" class="article-heading"><a href="#分叉处理" class="headerlink" title="分叉处理"></a>分叉处理<a class="article-anchor" href="#分叉处理" aria-hidden="true"></a></h4><ul>
<li><p>简述</p>
<ul>
<li>由于区块的开放特性，有可能网络上的某些对等节点是恶意的（有可能修改程序代码，因为开源），也有可能某些诚信节点因为网络、服务器等各种不稳定因素，造成错误区块，区块没有及时同步等情况；</li>
<li>出现这样的情况，有可能区块是恶意的，需要丢弃，也有可能区块是正确的，只是本节点接收时间延迟；那么最终判断这个区块是否被纳入主链的标准，则是看下一个出块节点是否接着本区块出块。</li>
<li>所以系统需要一个分叉处理器来处理节点运行过程中遇到的各种问题，保证全网主链的统一。</li>
</ul>
</li>
<li><p>流程图</p>
</li>
</ul>
<p><img src="consensus/9.png" alt="tips"></p>
<ul>
<li><p>代码解释</p>
<ul>
<li><p>调度器ConsensusScheduler会启动一个分叉处理任务</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ForkChainProcess forkChainProcess = <span class="keyword">new</span> ForkChainProcess(chainManager);</span><br><span class="line">threadPool.scheduleAtFixedRate(<span class="keyword">new</span> ForkChainProcessTask(forkChainProcess), <span class="number">1000L</span>, <span class="number">1000L</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>    该任务每秒执行一次，检测处理分叉区块。

* io.nuls.consensus.poc.task.ForkChainProcessTask直接调用io.nuls.consensus.poc.process.ForkChainProcess的doProcess方法。

* ForkChainProcess的doProcess方法会首先调用monitorOrphanChains方法对孤儿链进行处理，检测孤儿链的区块是否与主链或者分叉链相连，如果相连则合并，如果连不上则不做任务处理。

* 接下来检查分叉链，代码如下：

    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line"><span class="keyword">long</span> newestBlockHeight = chainManager.getBestBlockHeight() + PocConsensusConstant.CHANGE_CHAIN_BLOCK_DIFF_COUNT;</span><br><span class="line"></span><br><span class="line">         ChainContainer newChain = chainManager.getMasterChain();</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">null</span> == newChain) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         Iterator&lt;ChainContainer&gt; iterator = chainManager.getChains().iterator();</span><br><span class="line">         <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">             ChainContainer forkChain = iterator.next();</span><br><span class="line">             <span class="keyword">if</span> (forkChain.getChain() == <span class="keyword">null</span> || forkChain.getChain().getStartBlockHeader() == <span class="keyword">null</span> || forkChain.getChain().getEndBlockHeader() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 iterator.remove();</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">long</span> newChainHeight = forkChain.getChain().getEndBlockHeader().getHeight();</span><br><span class="line">             <span class="keyword">if</span> (newChainHeight &gt; newestBlockHeight || (newChainHeight == newestBlockHeight &amp;&amp; forkChain.getChain().getEndBlockHeader().getTime() &lt; newChain.getChain().getEndBlockHeader().getTime())) &#123;</span><br><span class="line">                 newChain = forkChain;</span><br><span class="line">                 newestBlockHeight = newChainHeight;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>


    检查所有的分叉链，是否有比主链高出3个块以上的，并且选出一条最长的分叉链出来，如果都没有，那么newChain依然为主链，否则为对应的分叉链。

* 检测newChain是否为主链，如果不为主链，说明找到了更长的分叉链

    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line"><span class="keyword">if</span> (!newChain.equals(chainManager.getMasterChain())) &#123;</span><br><span class="line"></span><br><span class="line">             ChainContainer resultChain = verifyNewChain(newChain);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (resultChain == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 chainManager.getChains().remove(newChain);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//Verify pass, try to switch chain</span></span><br><span class="line">                 <span class="comment">//验证通过，尝试切换链</span></span><br><span class="line">                 <span class="keyword">boolean</span> success = changeChain(resultChain, newChain);</span><br><span class="line">                 <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                     chainManager.getChains().remove(newChain);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>


* verifyNewChain方法为验证新的分叉链是否合法，主要是验证新链的区块打包人与区块里的coinbase交易、红黄牌处罚交易是否合法，如果不合法则删除该条分叉链。

* changeChain方法为切换这个更长的分叉链为主链，首先找到分叉点，回滚主链上分叉点之后的所有区块及交易；然后把新的分叉链的区块从分叉点处逐个验证并保存（包含区块头与交易）。如果成功，则设置分叉链为新的主链，如果失败则撤销。

* 链切换成功之后删除分叉链集合里的本条分叉链。

* 最后调用clearExpiredChain方法清除过期的孤立链、分叉链等，释放内存。
</code></pre>
              </div>
              <footer class="article-footer">
                <time class="article-footer-updated" datetime="2019-01-02T05:45:52.056Z" itemprop="dateModified">上次更新：2019-01-02</time>
                <a href="protocol.html" class="article-footer-prev" title="通用协议"><i class="fa fa-chevron-left"></i><span>上一页</span></a><a href="contract.html" class="article-footer-next" title="智能合约"><span>下一页</span><i class="fa fa-chevron-right"></i></a>
              </footer>
            </div>
          </div>
          <aside id="article-toc" role="navigation">
            <div id="article-toc-inner">
              <strong class="sidebar-title">目录</strong>
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、模块概述"><span class="toc-text">1、模块概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、模块功能"><span class="toc-text">2、模块功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-外部接口"><span class="toc-text">2.1 外部接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-POC功能需求分析"><span class="toc-text">2.2 POC功能需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#在POC系统中，有代理人、委托人、打包人、奖励人这四个角色。"><span class="toc-text">在POC系统中，有代理人、委托人、打包人、奖励人这四个角色。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#在POC系统中，有创建代理（创建共识节点）、停止代理节点（退出共识）、委托共识、取消委托四种业务逻辑。"><span class="toc-text">在POC系统中，有创建代理（创建共识节点）、停止代理节点（退出共识）、委托共识、取消委托四种业务逻辑。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#POC系统的两种处罚机制"><span class="toc-text">POC系统的两种处罚机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#POC内部系统的隐藏功能需求"><span class="toc-text">POC内部系统的隐藏功能需求</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#3、模块接口"><span class="toc-text">3、模块接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、模块架构"><span class="toc-text">4、模块架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、模块协议"><span class="toc-text">5、模块协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TX-TYPE-REGISTER-AGENT"><span class="toc-text">TX_TYPE_REGISTER_AGENT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TX-TYPE-JOIN-CONSENSUS"><span class="toc-text">TX_TYPE_JOIN_CONSENSUS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TX-TYPE-CANCEL-DEPOSIT"><span class="toc-text">TX_TYPE_CANCEL_DEPOSIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TX-TYPE-STOP-AGENT"><span class="toc-text">TX_TYPE_STOP_AGENT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TX-TYPE-YELLOW-PUNISH"><span class="toc-text">TX_TYPE_YELLOW_PUNISH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TX-TYPE-RED-PUNISH"><span class="toc-text">TX_TYPE_RED_PUNISH</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、核心流程"><span class="toc-text"> 6、核心流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建代理"><span class="toc-text">创建代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#委托共识"><span class="toc-text">委托共识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#停止代理"><span class="toc-text">停止代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#取消委托"><span class="toc-text">取消委托</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#共识轮次"><span class="toc-text">共识轮次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打包区块"><span class="toc-text">打包区块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#区块验证"><span class="toc-text">区块验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分叉处理"><span class="toc-text">分叉处理</span></a></li></ol></li>
              <a href="#" id="article-toc-top">回到顶部</a>
            </div>
          </aside>
        </div>
      </article>
      <aside id="sidebar" role="navigation">
  <div class="inner">
    <strong class="sidebar-title">基础</strong><a href="index.html" class="sidebar-link">总体架构</a><a href="modularity.html" class="sidebar-link">为什么模块化</a><a href="structure.html" class="sidebar-link">源码结构</a><a href="modular_overview.html" class="sidebar-link">模块说明</a><a href="micro_kernel.html" class="sidebar-link">微内核</a><a href="message_bus.html" class="sidebar-link">消息总线</a><strong class="sidebar-title">模块说明</strong><a href="network_overview.html" class="sidebar-link">网络模块</a><a href="storage.html" class="sidebar-link">存储模块</a><a href="account.html" class="sidebar-link">账户模块</a><a href="ledger.html" class="sidebar-link">账本模块</a><a href="protocol.html" class="sidebar-link">通用协议</a><a href="consensus.html" class="sidebar-link current">共识模块</a><a href="contract.html" class="sidebar-link">智能合约</a>
  </div>
</aside>
    </div>
  </div>
</div>

    <div class="footer-index" id="footer">
   <div class="footer-index-inner">
      <div class="footer-left">
         <div>© 2018 <a href="https://nuls.io" target="_blank">Nuls</a></div>
         <div>Documentation licensed under <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a></div>
         <div>Power by <a href="https://hexo.io" target="_blank">HEXO</a></div>
      </div>
      <div class="footer-middle">
        <div>
          <a href="https://twitter.com/nulsservice" target="_blank"><i class="footer-icon1"></i></a>
        </div>
        <div>
         <a href="https://www.reddit.com/r/nulsservice/" target="_blank"><i class="footer-icon2"></i></a>
        </div>
        <div>
          <a href="https://t.me/Nulsio" target="_blank"><i class="footer-icon3"></i></a>
        </div>
        <div>
           <a href="https://steemit.com/@nuls" target="_blank"><i class="footer-icon4"></i></a>
        </div>
        <div>
          <a href="https://github.com/nuls-io/nuls" target="_blank"><i class="footer-icon5"></i></a>
        </div>
        <div>
          <a href="https://www.facebook.com/nulscommunity/" target="_blank"><i class="footer-icon6"></i></a>
        </div>
        <div>
          <a href="https://join.slack.com/t/nuls/shared_invite/enQtMjQ4MTM4ODAyNTI4LWJjNGMwYTE0YjRlYmFlZGUwM2JhOGE4MDIwZmE4MzA2MDg1YzUyMmVkN2RhZjkyNWMzZjY5ZDU5ZmViMjZjNGQ" target="_blank"><i class="footer-icon7"></i></a>
        </div>
        <div>
          <a href="https://gitter.im/nuls_io" target="_blank"><i class="footer-icon8"></i></a>
        </div>
      </div>
   </div>
</div>
  </div>
  <div id="mobile-nav-dimmer"></div>
  <nav id="mobile-nav">
  <div id="mobile-nav-inner">
    <ul id="mobile-nav-list">
      <a href="/zh-cn/docs/" class="mobile-nav-link">文档</a><a href="/zh-cn/protocol/" class="mobile-nav-link">协议</a><a href="/zh-cn/contract/" class="mobile-nav-link">智能合约</a><a href="/zh-cn/chain/" class="mobile-nav-link">跨链</a><a href="/zh-cn/manual/" class="mobile-nav-link">参考手册</a><a href="/news/" class="mobile-nav-link">新闻</a>
      <li class="mobile-nav-item">
        <a href="https://github.com/nuls-io/nuls" class="mobile-nav-link" rel="external" target="_blank">GitHub</a>
      </li>
    </ul>
    
      <strong class="mobile-nav-title">基础</strong><a href="index.html" class="mobile-nav-link">总体架构</a><a href="modularity.html" class="mobile-nav-link">为什么模块化</a><a href="structure.html" class="mobile-nav-link">源码结构</a><a href="modular_overview.html" class="mobile-nav-link">模块说明</a><a href="micro_kernel.html" class="mobile-nav-link">微内核</a><a href="message_bus.html" class="mobile-nav-link">消息总线</a><strong class="mobile-nav-title">模块说明</strong><a href="network_overview.html" class="mobile-nav-link">网络模块</a><a href="storage.html" class="mobile-nav-link">存储模块</a><a href="account.html" class="mobile-nav-link">账户模块</a><a href="ledger.html" class="mobile-nav-link">账本模块</a><a href="protocol.html" class="mobile-nav-link">通用协议</a><a href="consensus.html" class="mobile-nav-link current">共识模块</a><a href="contract.html" class="mobile-nav-link">智能合约</a>
    
  </div>
  <div id="mobile-lang-select-wrap">
    <span id="mobile-lang-select-label"><i class="fa fa-globe"></i><span>简体中文</span></span>
    <select id="mobile-lang-select" data-canonical="manual/consensus.html">
      
        <option value="en">English</option>
      
        <option value="zh-cn" selected>简体中文</option>
      
    </select>
  </div>
</nav>
  <!-- Scripts -->
<!-- build:js build/js/main.js -->
<script src="/js/lang_select.js"></script>
<script src="/js/toc.js"></script>
<script src="/js/mobile_nav.js"></script>
<script src="/js/common.js"></script>
<!-- endbuild -->

</body>
</html>